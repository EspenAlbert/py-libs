from os import getenv
from pathlib import Path
from typing import ClassVar, Self, TypeVar

from model_lib.serialize.parse import parse_model
from pydantic import DirectoryPath, model_validator
from pydantic_settings import BaseSettings
from zero_3rdparty import file_utils

T = TypeVar("T")


def get_editor() -> str:
    return getenv("EDITOR", "code")


class PkgSettings(BaseSettings):
    PUBLIC_GROUPS_STORAGE_FILENAME: ClassVar[str] = ".groups.yaml"
    CHANGELOG_FILENAME: ClassVar[str] = "CHANGELOG.md"

    file_header: str = "# Generated by pkg-ext"
    repo_root: DirectoryPath
    pkg_directory: DirectoryPath
    skip_open_in_editor: bool = False
    dev_mode: bool = False

    def _with_dev_suffix(self, path: Path) -> Path:
        if self.dev_mode:
            return path.with_stem(f"{path.stem}-dev")
        return path

    def _without_dev_suffix(self, path: Path) -> Path:
        return path.with_stem(path.stem.replace("-dev", ""))

    @model_validator(mode="after")
    def check_paths(self) -> Self:
        assert self.pkg_directory.exists(), (
            f"Package directory does not exist: {self.pkg_directory}"
        )
        assert self.init_path.exists(), f"Init path does not exist: {self.init_path}"
        return self

    @property
    def init_path(self) -> Path:
        return self.pkg_directory / "__init__.py"

    @property
    def pkg_import_name(self) -> str:
        return self.pkg_directory.name

    @property
    def state_dir(self) -> DirectoryPath:
        return self.pkg_directory.parent

    @property
    def changelog_path(self) -> DirectoryPath:
        return self.state_dir / ".changelog"

    @property
    def changelog_md(self) -> Path:
        return self._with_dev_suffix(self.state_dir / self.CHANGELOG_FILENAME)

    @property
    def public_groups_path(self) -> Path:
        return self._with_dev_suffix(
            self.state_dir / self.PUBLIC_GROUPS_STORAGE_FILENAME
        )

    def parse_public_groups(self, t: type[T]) -> T:
        from pkg_ext.models import PublicGroups  # avoid dependency

        assert t is PublicGroups

        public_groups_path = self.public_groups_path
        no_suffix_path = self._without_dev_suffix(public_groups_path)
        if self.dev_mode and no_suffix_path.exists():
            file_utils.copy(no_suffix_path, public_groups_path)
        if public_groups_path.exists():
            public_groups = parse_model(public_groups_path, t=PublicGroups)
            public_groups.storage_path = public_groups_path
        else:
            public_groups = PublicGroups(storage_path=public_groups_path)
        return public_groups  # type: ignore


def pkg_settings(
    repo_root: Path,
    pkg_path: str,
    *,
    skip_open_in_editor: bool = False,
    dev_mode: bool = False,
) -> PkgSettings:
    return PkgSettings(
        repo_root=repo_root,
        pkg_directory=repo_root / pkg_path,
        skip_open_in_editor=skip_open_in_editor,
        dev_mode=dev_mode,
    )
